# Matlab脚本及Simulink仿真文件
里面的matlab函数和matlab简单仿真是基于Robot Toolbox for Matlab的，官网地址：https://petercorke.com/toolboxes/robotics-toolbox/</br>
如果想要不依靠这个工具箱来实现运动学算法部分，可以参考simulink里面的函数模块里面的写法。</br>
## 目录
1. [文件综述以及用处](#index1)
    *  [原理验证/调试用脚本](#index1.1)
    *  [Simulink仿真文件](#index1.2)
2. [编号规则和一些规定](#index2)
    * [腿的编号](#index2.1)
    * [实机调试输出的格式](#index2.2)
    * [一些设计时由于思路不清晰留下的怪东西](#index2.3)
3. [生成步态](#index3)
4. [生成舵机位置值（实机调试）](#index4)
5. [一次完整生成调试数据的过程示例](#index5)
6. [基于Robot Toolbox for Matlab的简单仿真](#index6)


## <span id ='index1'>文件综述以及用处
### <span id='index1.1'>原理验证/调试用脚本
一共18个.m文件
* 一个脚本中有所有机身机械参数，自定义的原点/不同复位的位置等参数，后续所有生成步态/舵机位置的脚本全部依靠这个文件里的全局坐标参数
    >data.m</br>
* 其中5个是函数
    >jointCo2jointAng.m　　　//将关节坐标系的坐标转换成关节角</br>
    >jointCo2worldCo.m　　　//将关节坐标系的坐标转换成世界坐标系的坐标</br>
    >worldCo2jointCo.m　　　//将世界坐标系的坐标转换成关节坐标系的坐标</br>
    >rotXYAng2jointAng.m　　//输入机身目标旋转的roll和pitch角度，输出六条腿的对应关节角</br>
    >genLeg.m　　　　　　　//生成一条腿的对象，基于Robot Toolbox for Matlab</br>
* 另外有6个gait_开头的脚本，用于生成6中步态的世界坐标/关节坐标/关节角等信息
    >gait_mv_backward.m　　　//后退步态</br>
    >gait_mv_forward.m　　　　//前进步态</br>
    >gait_mv_left.m　　　　　　//左平移步态</br>
    >gait_mv_right.m　　　　　//右平移步态</br>
    >gait_rot_clockwise.m　　　//顺时针旋转步态</br>
    >gait_rot_couterclk.m　　　//逆时针旋转步态</br>
* 5个gen_开头的脚本用于将已经生成好的坐标/关节角转换成AX-12A舵机的特定的位置值（0-1023对应0-300度），并写入到输出文件中，是用于机器人实机调试的
    >//一组舵机位置值：包含了18个舵机的数据</br>
    >//一条腿的舵机位置值：包含了3个舵机的数据</br>
    >gen_fullGait.m　　　　　　//把生成好的一种步态（上述6种gait）转换成舵机位置值</br>
    >gen_originAng.m　　　　　//生成一组静止站立时的舵机位置值（用于复位）</br>
    >gen_rotTo.m　　　　　　　//生成机身旋转到目标roll/pitch角的一组舵机位置值（用于静态测试姿态调整角度）</br>
    >gen_singleGait.m　　　　　//生成某一条腿/某几条腿的一种步态的舵机位置值（用于单腿测试）</br>
    >gen_dancing.m　　　　　　//生成一种诡异的舞蹈的一组舵机位置值</br>
* 一个基于Robot Toolbox for Matlab的简单的仿真脚本，可以方便的验证生成的关节角是否正确
    >simple_simulation.m</br>
### <span id='index1.2'> Simulink仿真文件
一个.slx文件
* 一个整机的simulink仿真文件，可以自定义步长步距等参数，仿真6种步态（前后左右移动+顺逆旋转）。
    >hexapod_LANGZHU.slx</br>

这个模型顶层封装的比较简单直观，双击gait generator和leg可以看到可以修改的参数和选择要仿真的步态，选好了运行即可，这一部分不再多加说明。</br>
内部的算法与其他的matlab是完全一样的，因为simulink的函数模块不支持部分功能所以里面有些地方换了个写法重写了一遍，不过原理和步骤是完全相同的。</br>

## <span id ='index2'>编号规则和一些规定
### <span id='index2.1'> 腿的编号
![布局图](https://raw.githubusercontent.com/Splinting/Mobile-Hexapod-Robot-LANGZHU/main/matlab%20code/pic/base.png)
（图片的上方为前进方向）</br>
默认的腿的编号如图，注意六条腿在空间上不是连续的，这种编号的初衷是1-3号腿和4-6号腿的步态状态是一样的（详见报告的三角步态部分），但是实际做到最后发现这种设计也不是特别必要。有点好处也有点坏处，就像是脑子里进水了，后来发现这水居然还能用来浇花。</br>
</br>

### <span id='index2.2'>实机调试输出的格式
* 比如这样的： 
    >appp=512+round(app./0.29);</br>
    >writematrix(appp,'out/originAng.txt','Delimiter',',');</br>

我们使用的AX-12舵机的默认复位位置是150°，可活动范围为0-300°，0-300°对应到0-1023的数字，所以我们生成的关节角通过这个公式变成舵机能够到达的实际位置。</br>
并且最后结果输出到一个文本文件里，里面数据的格式是python的数组格式，把里面的数据全部复制到python的整机控制代码里就能够直接使用。<br>
比如输出一组完整的步态，那么你输出的会是一个长长的数组，第1-18（0-17）个数字是1-18号舵机的第一个位置（第一帧），第19-36（18-35）个数字是1-18号舵机的第二个位置（第二帧），后面也同上。</br>
顺便，这里生成的所有步态相关的数据都是一整个步态周期的。</br>

### <span id='index2.3'>一些设计时由于思路不清晰留下的怪东西
在gen_开头的文件里，很多次出现了“机械位形调整”的说法。</br>
* 比如这样的：</br>
    >%机械位形的符号调整</br>
    >sign=[-1,1,1, -1,-1,-1, -1,1,1, -1,-1,-1, -1,1,1, -1,-1,-1];</br>
    >app=app.*sign;</br>
* 或者这样的：</br>
    >%机械位形的正负号调整</br>
    >origin_angle(1,:)=-origin_angle(1,:);</br>
    >for i=[2,4,6]  </br>
    >　origin_angle(2,i)=-origin_angle(2,i);</br>
    >　origin_angle(3,i)=-origin_angle(3,i);</br>
    >end</br>
   
仔细看这两个意思都一样，好像甚至还有别的版本(=_=)（每天脑子进的都是不同的水）。出现这个的原因是机械设计时没有注意舵机的方向，默认的关节角的正负定义应该参考报告里的DH建模部分；而我们进行实机的机械设计的时候，举个简单的例子，左右两边的腿是镜像对称的，这显然就有大问题（你可以看到上面的程序的一个作用是把2，4，6号腿的符号反过来了，246就是同一侧的腿，因为镜像的设计导致它们舵机的默认方向是反的）。总之这个问题完全是经验不足的智商税。</br>

## <span id='index3'> 生成步态
gait_开头的脚本用于生成某种步态的世界坐标，关节坐标以及关节角。可以修改的参数放在了脚本的最前面。</br>
* 比如这个：
    >%% </br>
    >L=2*80;　　　%前进距离（实际移动距离为80）</br>
    >H=50;　　　　%腿抬高高度</br>
    >nn=20;　　　%采样数（4的倍数）</br>

默认运行完这个脚本会出现步态曲线的图像和在空间中的坐标图像（世界坐标系），可以自行注释掉部分代码关掉。运行完这个脚本后生成的世界坐标，关节坐标以及关节角会被储存到matlab工作区以供后续使用。</br>
以gait_mv_forward.m为例，运行完后关节角被储存在trace_jointAng中，这是一个1x6的元胞数组（这代表1-6号腿），其中每一个元胞为一个3x20（nn默认为20）的矩阵。对这个3x20的矩阵，它的每一列就是运动过程的一帧，一列的三个值就是这一时刻的三个关节角（编号规则参考DH建模过程和整机的腿号）（比如1号元胞的第一帧是123号舵机的第一帧，4号元胞的第6帧是10 11 12号舵机的第六帧）。</br>


## <span id='index4'> 生成舵机位置值（实机调试）
gen_开头的脚本能生成一些舵机的位置值，直接把结果写入输出文件中，用于测试。但是注意某些脚本需要在依靠前面的脚本运行，比如想要测试行走步态，先要运行gait_xxx.m，生成关节角，再运行gen_xxGait.m生成舵机位置值。</br>
这一部分的内容属于理论和具体硬件实现方法的转化，如果不是用的AX-12A这款舵机的话就不需要这一步，或者是需要其他的计算方法，比如pwm控制就和这个计算方法不同。</br>


## <span id='index5'> 一次完整生成调试数据的过程示例
以生成一个整机的左移步态测试数据为例：</br>
* 运行data.m　　　　　　　-->全局变量被导入工作区</br>
* 运行gait_mv_left.m　　　-->出现步态的图像，检查与预期无误</br>
* 运行gen_fullGait.m　　　-->out文件夹下出现fullGait.txt文件夹，打开发现里面有有效数据</br>
* 把数据拷贝到python控制代码的对应位置，运行测试</br>

## <span id='index6'>基于Robot Toolbox for Matlab的简单仿真
simple_simulation.m这个脚本能够进行单条腿的简单仿真，用于检查生成的关节角的正确性或者生成单腿的工作空间等。</br>
运行前也需要先运行data.m，导入全局变量。</br>
* 生成基础布局：运行第一小节：生成六条腿，此时能看到生成的六条腿。</br>
![布局图](https://raw.githubusercontent.com/Splinting/Mobile-Hexapod-Robot-LANGZHU/main/matlab%20code/pic/configuration.png)
* 简单可视化轨迹：【运行第一小节后】，再运行任一步态生成脚本（gait_xxx.m），再运行第二小节：可以看到六条腿按照预定轨迹运动的动画。不过这个工具箱只能六条腿一个一个的动，所以意义不大，只是用来看一眼生成的关节角有没有问题。</br>
* 复位：【运行第一、二小节后】，或者用其他脚本使腿移动到其他地方后，运行第四小节：能够使所有腿复位。</br>
* 查看工作空间：运行第三小节（无需运行其他小节）：可以生成一条腿的工作空间，蓝色为低机位，红色为高机位（高低机位的定义见报告）。</br>

工具箱的可视化函数功能还是有限，仿真完整运动请见simulink仿真文件。

